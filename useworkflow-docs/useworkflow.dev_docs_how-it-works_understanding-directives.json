{
  "markdown": "[Vercel](https://vercel.com/) Slash [Workflow DevKit LogoWorkflow](https://useworkflow.dev/)\n\n- [Docs](https://useworkflow.dev/docs)\n- [Examples](https://github.com/vercel/workflow-examples)\n\n[X](https://x.com/workflowdevkit) [GitHub](https://github.com/vercel/workflow) Search... `⌘K`Ask AI\n\nAsk AI\n\nSearch... `⌘K`\n\n[Getting Started](https://useworkflow.dev/docs/getting-started)\n\n- [Next.js](https://useworkflow.dev/docs/getting-started/next)\n- [Vite](https://useworkflow.dev/docs/getting-started/vite)\n- [Astro](https://useworkflow.dev/docs/getting-started/astro)\n- [Express](https://useworkflow.dev/docs/getting-started/express)\n- [Fastify](https://useworkflow.dev/docs/getting-started/fastify)\n- [Hono](https://useworkflow.dev/docs/getting-started/hono)\n- [Nitro](https://useworkflow.dev/docs/getting-started/nitro)\n- [Nuxt](https://useworkflow.dev/docs/getting-started/nuxt)\n- [SvelteKit](https://useworkflow.dev/docs/getting-started/sveltekit)\n\n[Foundations](https://useworkflow.dev/docs/foundations)\n\n- [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps)\n- [Starting Workflows](https://useworkflow.dev/docs/foundations/starting-workflows)\n- [Control Flow Patterns](https://useworkflow.dev/docs/foundations/control-flow-patterns)\n- [Errors & Retrying](https://useworkflow.dev/docs/foundations/errors-and-retries)\n- [Hooks & Webhooks](https://useworkflow.dev/docs/foundations/hooks)\n- [Streaming](https://useworkflow.dev/docs/foundations/streaming)\n- [Serialization](https://useworkflow.dev/docs/foundations/serialization)\n- [Idempotency](https://useworkflow.dev/docs/foundations/idempotency)\n\nHow it works\n\n[Observability](https://useworkflow.dev/docs/observability)\n\nAI Agents\n\n- [Building Durable AI Agents](https://useworkflow.dev/docs/ai)\n- [Streaming Updates from Tools](https://useworkflow.dev/docs/ai/streaming-updates-from-tools)\n- [Resumable Streams](https://useworkflow.dev/docs/ai/resumable-streams)\n- [Sleep, Suspense, and Scheduling](https://useworkflow.dev/docs/ai/sleep-and-delays)\n- [Human-in-the-Loop](https://useworkflow.dev/docs/ai/human-in-the-loop)\n- [Patterns for Defining Tools](https://useworkflow.dev/docs/ai/defining-tools)\n- [Chat Session Modeling](https://useworkflow.dev/docs/ai/chat-session-modeling)\n\n[Deploying](https://useworkflow.dev/docs/deploying)\n\n[Errors](https://useworkflow.dev/docs/errors)\n\n[API Reference](https://useworkflow.dev/docs/api-reference)\n\nUnderstanding DirectivesWorkflows and Steps Primer\n\nHow it works\n\n# Understanding Directives\n\nThis guide explores how JavaScript directives enable the Workflow DevKit's execution model. For getting started with workflows, see the [getting started](https://useworkflow.dev/docs/getting-started) guides for your framework.\n\nThe Workflow Development Kit uses JavaScript directives (`\"use workflow\"` and `\"use step\"`) as the foundation for its durable execution model. Directives provide the compile-time semantic boundary necessary for workflows to suspend, resume, and maintain deterministic behavior across replays.\n\nThis page explores how directives enable this execution model and the design principles that led us here.\n\nTo understand how directives work, let's first understand what workflows and steps are in the Workflow DevKit.\n\n## [Workflows and Steps Primer](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#workflows-and-steps-primer)\n\nThe Workflow DevKit has two types of functions:\n\n**Step functions** are side-effecting operations with full Node.js runtime access. Think of them like named RPC calls - they run once, their result is persisted, and they can be [retried on failure](https://useworkflow.dev/docs/foundations/errors-and-retries):\n\n```\nasync function fetchUserData(userId: string) {\n  \"use step\";\n\n  // Full Node.js access: database calls, API requests, file I/O\n  const user = await db.query(\"SELECT * FROM users WHERE id = ?\", [userId]);\n  return user;\n}\n```\n\n**Workflow functions** are deterministic orchestrators that coordinate steps. They must be pure functions - during replay, the same step results always produce the same output. This is necessary because workflows resume by replaying their code from the beginning using cached step results; non-deterministic logic would break resumption. They run in a sandboxed environment without direct Node.js access:\n\n```\nexport async function onboardUser(userId: string) {\n  \"use workflow\";\n\n  const user = await fetchUserData(userId); // Calls step\n\n  // Non-deterministic code would break replay behavior\n  if (Math.random() > 0.5) {\n    await sendWelcomeEmail(user);\n  }\n\n  return `Onboarded ${user.name}!`;\n}\n```\n\n**The key insight:** Workflows resume from suspension by replaying their code using cached step results from the [event log](https://useworkflow.dev/docs/how-it-works/event-sourcing). When a step like `await fetchUserData(userId)` is called:\n\n- **If already executed:** Returns the cached result immediately from the event log\n- **If not yet executed:** Suspends the workflow, enqueues the step for background execution, and resumes later with the result\n\nThis replay mechanism requires deterministic code. If `Math.random()` weren't seeded, the first execution might return `0.7` (sending the email) but replay might return `0.3` (skipping it), thus breaking resumption. The Workflow DevKit sandbox provides seeded `Math.random()` and `Date` to ensure consistent behavior across replays.\n\nFor a deeper dive into workflows and steps, see [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps).\n\n## [The Core Challenge](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#the-core-challenge)\n\nThis execution model enables powerful durability features - workflows can suspend for days, survive restarts, and resume from any point. However, it also requires a semantic boundary in the code that tells **the compiler, runtime, and developer** that execution semantics have changed.\n\nThe challenge: how do we mark this boundary in a way that:\n\n1. Enables compile-time transformations and validation\n2. Prevents accidental use of non-deterministic APIs\n3. Allows static analysis of workflow structure\n4. Feels natural to JavaScript developers\n\nLet's look at where directives have been used before, and the alternatives we considered:\n\n## [Prior art on directives](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#prior-art-on-directives)\n\nJavaScript directives have precedent for changing execution semantics within a defined scope:\n\n- `\"use strict\"` (introduced in ECMAScript 5 in 2009, TC39-standardized) changes language rules to make the runtime faster, safer, and more predictable.\n- `\"use client\"` and `\"use server\"` (introduced by [React Server Components](https://react.dev/reference/rsc/server-components)) define an explicit boundary of \"where\" code gets executed - client-side browser JavaScript vs server-side Node.js.\n- `\"use workflow\"` (introduced by the Workflow DevKit) defines both \"where\" code runs (in a deterministic sandbox environment) and \"how\" it runs (deterministic, resumable, sandboxed execution semantics).\n\nDirectives provide a build-time contract.\n\nWhen the Workflow DevKit sees `\"use workflow\"`, it:\n\n- Bundles the workflow and its dependencies into code that can be run in a sandbox\n- Restricts access to Node.js APIs in that sandbox\n- Enables future functionality and optimizations only possible with a build tool\n  - For instance, the bundled workflow code can be statically analyzed to generate UML diagrams/visualizations of the workflow\n\nIn addition to being important to the compiler, `\"use workflow\"` explicitly signals to the developer that you are entering a different execution mode.\n\nThe `\"use workflow\"` directive is also used by the Language Server Plugin shipped with Workflow DevKit to provide IntelliSense to your IDE. Check the [getting started instructions](https://useworkflow.dev/docs/getting-started) for your framework for details on setting up the Language Server Plugin.\n\nBut we didn't get here immediately. This took some discovery to arrive at:\n\n## [Alternatives We Explored](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#alternatives-we-explored)\n\nBefore settling on directives, we prototyped several other approaches. Each had significant limitations that made them unsuitable for production use.\n\n### [Runtime-Only \"Suspense\" API](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#runtime-only-suspense-api)\n\nOur first proof of concept used a wrapper-based API without a build step:\n\n```\nexport const myWorkflow = workflow(() => {\n  const message = run(async () => step());\n  return `${message}!`;\n});\n```\n\nThis implementation used \"throwing promises\" (similar to early React Suspense) to suspend execution. When a step needed to run, we'd throw a promise, catch it at the workflow boundary, execute the step, and replay the workflow with the result.\n\n**The problems:**\n\n**1\\. Every side effect needed wrapping**\n\nAny operation that could produce non-deterministic results had to be wrapped in `run()`:\n\n```\nexport const myWorkflow = workflow(async () => {\n  // These would be non-deterministic without wrapping\n  const now = await run(() => Date.now());\n  const random = await run(() => Math.random());\n  const user = await run(() => fetchUser());\n\n  return { now, random, user };\n});\n```\n\nThis was verbose and easy to forget. Moreover, if a developer forgot to wrap something innocent like using `Date.now()`, it led to unstable runtime behavior.\n\nFor example:\n\n```\nexport const myWorkflow = workflow(async () => {\n  // Nothing stops you from doing this:\n  const now = Date.now(); // Non-deterministic, untracked!\n  const user = await run(() => fetchUser());\n\n  // This workflow would produce different results on replay\n  return { now, user };\n});\n```\n\n**2\\. Closures and mutation became unpredictable**\n\nVariables captured in closures would behave unexpectedly when steps mutated them:\n\n```\nexport const myWorkflow = workflow(async () => {\n  let counter = 0;\n\n  await run(() => {\n    counter++; // This mutation happens during step execution\n    return saveToDatabase(counter);\n  });\n\n  console.log(counter); // What is counter here?\n  // During execution: 1 (mutation preserved)\n  // During replay: 0 (mutation lost)\n  // Inconsistent behavior!\n});\n```\n\nThe workflow function would replay multiple times, but mutations inside `run()` callbacks wouldn't persist across replays. This made reasoning about state nearly impossible.\n\n**3\\. Error handling broke down**\n\nSince we used thrown promises for control flow, `try/catch` blocks became unreliable:\n\n```\nexport const myWorkflow = workflow(async () => {\n  try {\n    const result = await run(() => step());\n    return result;\n  } catch (error) {\n    // This could catch:\n    // 1. A real error from the step\n    // 2. The thrown promise used for suspension\n    // 3. An error during replay\n    // Hard to distinguish without special handling\n    console.error(error);\n  }\n});\n```\n\n### [Generator-Based API](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#generator-based-api)\n\nWe explored using generators for explicit suspension points, inspired by libraries like Effect.ts:\n\n```\nexport const myWorkflow = workflow(function*() {\n  const message = yield* run(() => step());\n  return `${message}!`;\n});\n```\n\nWe're big fans of [Effect.ts](https://effect.website/) and the power of generator-based APIs for effect management. However, for workflow orchestration specifically, we found the syntax too heavy for developers unfamiliar with generators.\n\n**The problems:**\n\n**1\\. Syntax felt more like a DSL than JavaScript**\n\nGenerators require a custom mental model that differs significantly from familiar async/await patterns. The `yield*` syntax and generator delegation were unfamiliar to many developers:\n\n```\n// Standard async/await (familiar)\nconst result = await fetchData();\n\n// Generator-based (unfamiliar)\nconst result = yield* run(() => fetchData());\n```\n\nComplex workflows became particularly verbose and difficult to read:\n\n```\nexport const myWorkflow = workflow(function*() {\n  const user = yield* run(() => fetchUser());\n\n  // Can't use Promise.all directly - need sequential calls or custom helpers\n  const orders = yield* run(() => fetchOrders(user.id));\n  const payments = yield* run(() => fetchPayments(user.id));\n\n  // Or create a custom generator-aware parallel helper:\n  const [orders2, payments2] = yield* all([\\\n    run(() => fetchOrders(user.id)),\\\n    run(() => fetchPayments(user.id))\\\n  ]);\n\n  return { user, orders, payments };\n});\n```\n\n**2\\. Still no compile-time sandboxing**\n\nLike the runtime-only approach, generators couldn't prevent non-deterministic code:\n\n```\nexport const myWorkflow = workflow(function*() {\n  const now = Date.now(); // Still possible, still problematic\n  const user = yield* run(() => fetchUser());\n  return { now, user };\n});\n```\n\nThe generator syntax addressed suspension but didn't solve the fundamental sandboxing problem.\n\n### [File System-Based Conventions](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#file-system-based-conventions)\n\nWe explored using file system conventions to identify workflows and steps, similar to how modern frameworks handle routing (Next.js, Hono, Nitro, SvelteKit):\n\nworkflows\n\nonboarding.ts\n\ncheckout.ts\n\nsteps\n\nsend-email.ts\n\ncharge-payment.ts\n\nWith this approach, any function in the `workflows/` directory would be transformed as a workflow, and any function in `steps/` would be a step. No directives needed, just file locations.\n\n**Why this could work:**\n\n- Clear separation of concerns\n- Enables compiler transformations based on file path\n- Familiar pattern for developers used to file-based routing, for example Next.js\n\n**Why we moved away:**\n\n**1\\. Too opinionated for diverse ecosystems**\n\nDifferent frameworks and developers have strong opinions about project structure. Forcing a specific directory layout often caused conflicts across various conventions, especially in existing codebases.\n\n**2\\. No support for publishable, reusable functions**\n\nWe want developers to be able to publish libraries to npm that include step and workflow directives. Ideally, logic that is isomorphic so it could be used with and without Workflow DevKit. File system conventions made this impossible.\n\n**3\\. Migration and code reuse became difficult**\n\nMigrating existing code required moving files and restructuring projects rather than adding a single line.\n\nThe directive approach solved all these issues: it works in any project structure, supports code reuse and migration, enables npm packages, and allows functions to adapt to their execution context.\n\n### [Decorators](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#decorators)\n\nWe considered decorators, but they presented significant challenges both technical and ergonomic.\n\n**Decorators are non-yet-standard and class-focused**\n\nDecorators are not yet a standard syntax ( [TC39 proposal](https://github.com/tc39/proposal-decorators)) and they currently only work with classes. A class decorator approach could look like this:\n\n```\nimport {workflow, step} from \"workflow\";\n\nclass MyWorkflow {\n  @workflow()\n  static async processOrder(orderId: string) {\n    const order = await this.fetchOrder(orderId);\n    const payment = await this.processPayment(order);\n    return { orderId, payment };\n  }\n\n  @step()\n  static async fetchOrder(orderId: string) {\n    // ...\n  }\n}\n```\n\nThis approach requires:\n\n- Writing class boilerplate with static methods\n- Storing/mutating class properties was not obvious (similar closure/mutation issues as the runtime-only approach)\n- Class-based syntax that doesn't feel \"JavaScript native\" to developers used to functional patterns\n\nAs the JavaScript ecosystem has moved toward function-forward programming (exemplified by React's shift from class components to functions and hooks), requiring developers to use classes felt like a step backward and also didn't match our own personal taste as authors of the DevKit.\n\n**The core problem: Presents workflows as regular runtime code**\n\nWhile decorators can be handled at compile-time with build tool support, they present workflow functions as if they were regular, composable JavaScript code, when they're actually compile-time declarations that need special handling.\n\nSee the [Macro Wrapper](https://useworkflow.dev/docs/how-it-works/understanding-directives#macro-wrapper-approach) section below for a deeper dive into why this approach breaks down with concrete examples.\n\n### [Macro Wrapper Approach](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#macro-wrapper-approach)\n\nWe also explored compile-time macro approaches - using a compiler to transform wrapper functions or decorators into directive-based code:\n\n```\n// Function wrapper approach\nimport { useWorkflow } from \"workflow\"\n\nexport const processOrder = useWorkflow(async (orderId: string) => {\n  const order = await fetchOrder(orderId);\n  return { orderId };\n});\n\n// Decorator approach (would work similarly)\nclass MyWorkflow {\n  @workflow()\n  static async processOrder(orderId: string) {\n    const order = await fetchOrder(orderId);\n    return { orderId };\n  }\n\n  // ...\n}\n```\n\nThe compiler could transform both to be equivalent to WDK's directive approach:\n\n```\nexport const processOrder = async (orderId: string) => {\n  \"use workflow\";\n  const order = await fetchOrder(orderId);\n  return { orderId };\n};\n```\n\nThe benefit is that macros could enforce types and provide \"Go To Definition\" or other LSP features out of the box.\n\nHowever, **the core problem remains: Workflows aren't runtime values**\n\nThe fundamental issue is that both wrappers and decorators make workflows appear to be **first-class, runtime values** when they're actually **compile-time declarations**. This mismatch between syntax and semantics creates numerous failure modes.\n\n**Concrete examples of how this breaks:**\n\n```\n// Someone writes a \"helpful\" utility\nfunction withRetry(fn: Function) {\n  return useWorkflow(async (...args) => { // Works with useWorkflow\n    try {\n      return await fn(...args);\n    } catch (error) {\n      return await fn(...args); // Retry once\n    }\n  });\n}\n\n// Note: the same utility would be written similarly for a decorator based syntax\n\n// Usage looks innocent in both cases\nexport const processOrder = withRetry(async (orderId: string) => {\n  // Is this deterministic? Can it call steps?\n  // Nothing in this function indicates the developer is in the\n  // deterministic sandboxed workflow\n  // Also where is the retry happening? inside or outside the workflow?\n  const order = await fetchOrder(orderId);\n  return order;\n});\n```\n\nThe developer writing `processOrder` has no visible signal that they're in a deterministic, sandboxed environment. It's also ambiguous whether the retry logic executes inside the workflow or outside, and the actual behavior likely doesn't match developer intuition.\n\n**Why the compiler can't catch this:**\n\nTo detect that `processOrder` is actually a workflow, the compiler would need whole-program analysis to track that:\n\n1. `withRetry` returns the result of `useWorkflow`\n2. Therefore `processOrder = withRetry(...)` is a workflow\n3. The function passed to `withRetry` will execute in a sandboxed context\n\nThis level of cross-function analysis is impractical for build tools - it would require analyzing every function call chain in your entire codebase and all dependencies. The compiler can only reliably detect direct `useWorkflow` calls, not calls hidden behind abstractions.\n\n## [How Directives Solve These Problems](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#how-directives-solve-these-problems)\n\nDirectives address all the issues we encountered with previous approaches:\n\n**1\\. Compile-time semantic boundary**\n\nThe `\"use workflow\"` directive tells the compiler to treat this code differently:\n\n```\nexport async function processOrder(orderId: string) {\n  \"use workflow\"; // Compiler knows: transform this for sandbox execution\n\n  const order = await fetchOrder(orderId); // Compiler knows: this is a step call\n  return { orderId, order };\n}\n```\n\n**2\\. Build-time validation**\n\nThe compiler can enforce restrictions before deployment:\n\n```\nexport async function badWorkflow() {\n  \"use workflow\";\n\n  const crypto = require(\"crypto\"); // Build error: Node.js module in workflow\n  return crypto.randomBytes(16);\n}\n```\n\nIn fact, Workflow DevKit will throw an error that links to this error page: [Node.js module in workflow](https://useworkflow.dev/docs/errors/node-js-module-in-workflow)\n\n**3\\. No closure ambiguity**\n\nSteps are transformed into function calls that communicate with the runtime:\n\n```\nexport async function processOrder(orderId: string) {\n  \"use workflow\";\n\n  let counter = 0;\n\n  // This essentially becomes: await enqueueStep(\"updateCounter\", [counter])\n  // The step receives counter as a parameter, not a closure\n  await updateCounter(counter);\n\n  console.log(counter); // Always 0, consistently\n}\n```\n\nCallbacks, however, run inside the workflow sandbox and work as expected:\n\n```\nexport async function processOrders(orderIds: string[]) {\n  \"use workflow\";\n\n  let successCount = 0;\n\n  // Callbacks run in the workflow context, not skipped on replay\n  await Promise.all(orderIds.map(async (orderId) => {\n    const order = await fetchOrder(orderId); // Step call\n    if (order.status === \"completed\") {\n      successCount++; // Mutation works correctly\n    }\n  }));\n\n  console.log(successCount); // Consistent across replays\n  return { total: orderIds.length, successful: successCount };\n}\n```\n\nThe callback runs in the workflow sandbox, so closure reads and mutations behave consistently across replays.\n\n**4\\. Natural syntax**\n\nLooks and feels like regular JavaScript:\n\n```\nexport async function processOrder(orderId: string) {\n  \"use workflow\";\n\n  // Standard async/await patterns work naturally\n  const [order, user] = await Promise.all([\\\n    fetchOrder(orderId),\\\n    fetchUser(userId)\\\n  ]);\n\n  return { order, user };\n}\n```\n\n**5\\. Consistent syntax for steps**\n\nThe `\"use step\"` directive maintains consistency. While steps run in the full Node.js runtime and _could_ work without a directive, they need some way to signal to the workflow runtime that they're steps.\n\nWe could have used a function wrapper just for steps:\n\n```\n// Mixed approach (inconsistent)\nexport async function processOrder(orderId: string) {\n  \"use workflow\"; // Directive for workflow\n\n  const order = await step(async () => fetchOrder(orderId));\n  return order;\n}\n\nconst fetchOrder = useStep(() => { // Wrapper for step?\n  // ...\n})\n```\n\nMixing syntaxes felt inconsistent.\n\nAn alternative approach we considered was to treat _all_ async function calls as steps by default:\n\n```\nexport async function processOrder(orderId: string) {\n  \"use workflow\";\n\n  // Every async call becomes a step automatically?\n  const [order, user] = await Promise.all([\\\n    fetchOrder(orderId), // Step\\\n    fetchUser(userId)    // Step\\\n  ]);\n\n  return { order, user };\n}\n```\n\nThis breaks down because many valid async operations inside workflows aren't steps:\n\n```\nexport async function processOrder(orderId: string) {\n  \"use workflow\";\n\n  // These are valid async calls that SHOULD NOT be steps:\n  const results = await Promise.all([...]); // Language primitive\n  const winner = await Promise.race([...]); // Language primitive\n\n  // Helper function that formats data\n  const formatted = await formatOrderData(order); // Pure JavaScript helper\n}\n```\n\nBy requiring explicit `\"use step\"` directives, developers have fine-grained control over what becomes a durable, retryable step versus what runs inline in the workflow sandbox.\n\nTo understand how directives are transformed at compile time, see [How the Code Transform Works](https://useworkflow.dev/docs/how-it-works/code-transform).\n\n## [What Directives Enable](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#what-directives-enable)\n\nBecause `\"use workflow\"` defines a compile-time semantic boundary, we can provide:\n\n### Build-Time Validation\n\nThe compiler catches invalid patterns before deployment: detects disallowed imports, prevents direct side effects, and validates workflow structure.\n\n### Static Analysis\n\nAnalyze workflow code without executing it: generate UML or DAG diagrams automatically, provide observability and visualization, and optimize execution paths.\n\n### Durable Execution\n\nWorkflows can safely suspend and resume: persist execution state between steps, resume from checkpoints after failures or deploys, and scale to zero without losing progress.\n\n### Future Optimizations\n\nThe semantic boundary enables planned improvements: smaller serialized state for faster checkpoints, smarter scheduling based on workflow structure, and more efficient suspension and resumption.\n\n## [Directives as a JavaScript Pattern](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#directives-as-a-javascript-pattern)\n\nDirectives in JavaScript have always been contracts between the developer and the execution environment. `\"use strict\"` made this pattern familiar - it's a string literal that changes how code is interpreted.\n\nWhile JavaScript doesn't yet have first-class support for custom directives (like Rust's `#[attribute]` or C++'s `#pragma`), string literal directives are the most pragmatic tool available today.\n\nAs TC39 members, we at Vercel are actively working with the standards body and broader ecosystem to explore formal specifications for pragma-like syntax or macro annotations that can express execution semantics.\n\n## [Closing Thoughts](https://useworkflow.dev/docs/how-it-works/understanding-directives\\#closing-thoughts)\n\nDirectives aren't about syntax preference, they're about expressing semantic boundaries. `\"use workflow\"` tells the compiler, developer, and runtime that this code is deterministic, resumable, and sandboxed.\n\nThis clarity enables the Workflow Development Kit to provide durable execution with familiar JavaScript patterns, while maintaining the compile-time guarantees necessary for reliable workflow orchestration.\n\n[Idempotency\\\\\n\\\\\nPrevious Page](https://useworkflow.dev/docs/foundations/idempotency) [How the Directives Work\\\\\n\\\\\nNext Page](https://useworkflow.dev/docs/how-it-works/code-transform)\n\nOn this page\n\n[Workflows and Steps Primer](https://useworkflow.dev/docs/how-it-works/understanding-directives#workflows-and-steps-primer) [The Core Challenge](https://useworkflow.dev/docs/how-it-works/understanding-directives#the-core-challenge) [Prior art on directives](https://useworkflow.dev/docs/how-it-works/understanding-directives#prior-art-on-directives) [Alternatives We Explored](https://useworkflow.dev/docs/how-it-works/understanding-directives#alternatives-we-explored) [Runtime-Only \"Suspense\" API](https://useworkflow.dev/docs/how-it-works/understanding-directives#runtime-only-suspense-api) [Generator-Based API](https://useworkflow.dev/docs/how-it-works/understanding-directives#generator-based-api) [File System-Based Conventions](https://useworkflow.dev/docs/how-it-works/understanding-directives#file-system-based-conventions) [Decorators](https://useworkflow.dev/docs/how-it-works/understanding-directives#decorators) [Macro Wrapper Approach](https://useworkflow.dev/docs/how-it-works/understanding-directives#macro-wrapper-approach) [How Directives Solve These Problems](https://useworkflow.dev/docs/how-it-works/understanding-directives#how-directives-solve-these-problems) [What Directives Enable](https://useworkflow.dev/docs/how-it-works/understanding-directives#what-directives-enable) [Directives as a JavaScript Pattern](https://useworkflow.dev/docs/how-it-works/understanding-directives#directives-as-a-javascript-pattern) [Closing Thoughts](https://useworkflow.dev/docs/how-it-works/understanding-directives#closing-thoughts)\n\n[GitHubEdit this page on GitHub](https://github.com/vercel/workflow/edit/main/content/docs/how-it-works/understanding-directives.mdx) Scroll to topGive feedbackCopy pageAsk AI about this pageOpen in chat\n\n## Chat\n\nWhat is Workflow?How does retrying work?What control flow patterns are there?How do directives work?How do I build an AI agent?\n\nTip: You can open and close chat with `⌘I`\n\n0 / 1000",
  "metadata": {
    "og:title": "Understanding Directives",
    "ogImage": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "language": "en",
    "title": "Understanding Directives",
    "og:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "og:image:width": "1200",
    "viewport": "width=device-width, initial-scale=1",
    "og:image:height": "628",
    "twitter:title": "Understanding Directives",
    "twitter:image:width": "1200",
    "twitter:image:type": "image/png",
    "twitter:card": "summary_large_image",
    "twitter:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "ogTitle": "Understanding Directives",
    "og:image:type": "image/png",
    "next-size-adjust": "",
    "twitter:image:height": "628",
    "favicon": "https://useworkflow.dev/favicon.ico?favicon.e7ce0d1c.ico",
    "scrapeId": "019bf2d4-569c-75d7-940f-c626a446ae9e",
    "sourceURL": "https://useworkflow.dev/docs/how-it-works/understanding-directives",
    "url": "https://useworkflow.dev/docs/how-it-works/understanding-directives",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic",
    "cacheState": "hit",
    "cachedAt": "2026-01-24T22:01:05.014Z",
    "creditsUsed": 1
  }
}