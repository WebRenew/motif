{
  "markdown": "[Vercel](https://vercel.com/) Slash [Workflow DevKit LogoWorkflow](https://useworkflow.dev/)\n\n- [Docs](https://useworkflow.dev/docs)\n- [Examples](https://github.com/vercel/workflow-examples)\n\n[X](https://x.com/workflowdevkit) [GitHub](https://github.com/vercel/workflow) Search... `⌘K`Ask AI\n\nAsk AI\n\nSearch... `⌘K`\n\n[Getting Started](https://useworkflow.dev/docs/getting-started)\n\n- [Next.js](https://useworkflow.dev/docs/getting-started/next)\n- [Vite](https://useworkflow.dev/docs/getting-started/vite)\n- [Astro](https://useworkflow.dev/docs/getting-started/astro)\n- [Express](https://useworkflow.dev/docs/getting-started/express)\n- [Fastify](https://useworkflow.dev/docs/getting-started/fastify)\n- [Hono](https://useworkflow.dev/docs/getting-started/hono)\n- [Nitro](https://useworkflow.dev/docs/getting-started/nitro)\n- [Nuxt](https://useworkflow.dev/docs/getting-started/nuxt)\n- [SvelteKit](https://useworkflow.dev/docs/getting-started/sveltekit)\n\n[Foundations](https://useworkflow.dev/docs/foundations)\n\n- [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps)\n- [Starting Workflows](https://useworkflow.dev/docs/foundations/starting-workflows)\n- [Control Flow Patterns](https://useworkflow.dev/docs/foundations/control-flow-patterns)\n- [Errors & Retrying](https://useworkflow.dev/docs/foundations/errors-and-retries)\n- [Hooks & Webhooks](https://useworkflow.dev/docs/foundations/hooks)\n- [Streaming](https://useworkflow.dev/docs/foundations/streaming)\n- [Serialization](https://useworkflow.dev/docs/foundations/serialization)\n- [Idempotency](https://useworkflow.dev/docs/foundations/idempotency)\n\nHow it works\n\n[Observability](https://useworkflow.dev/docs/observability)\n\nAI Agents\n\n- [Building Durable AI Agents](https://useworkflow.dev/docs/ai)\n- [Streaming Updates from Tools](https://useworkflow.dev/docs/ai/streaming-updates-from-tools)\n- [Resumable Streams](https://useworkflow.dev/docs/ai/resumable-streams)\n- [Sleep, Suspense, and Scheduling](https://useworkflow.dev/docs/ai/sleep-and-delays)\n- [Human-in-the-Loop](https://useworkflow.dev/docs/ai/human-in-the-loop)\n- [Patterns for Defining Tools](https://useworkflow.dev/docs/ai/defining-tools)\n- [Chat Session Modeling](https://useworkflow.dev/docs/ai/chat-session-modeling)\n\n[Deploying](https://useworkflow.dev/docs/deploying)\n\n[Errors](https://useworkflow.dev/docs/errors)\n\n[API Reference](https://useworkflow.dev/docs/api-reference)\n\nHow the Directives WorkDirectives Overview\n\nHow it works\n\n# How the Directives Work\n\nThis is an advanced guide that dives into internals of the Workflow DevKit directive and is not required reading to use workflows. To simply use the Workflow DevKit, check out the [getting started](https://useworkflow.dev/docs/getting-started) guides for your framework.\n\nWorkflows use special directives to mark code for transformation by the Workflow DevKit compiler. This page explains how `\"use workflow\"` and `\"use step\"` directives work, what transformations are applied, and why they're necessary for durable execution.\n\n## [Directives Overview](https://useworkflow.dev/docs/how-it-works/code-transform\\#directives-overview)\n\nWorkflows use two directives to mark functions for special handling:\n\n```\nexport async function handleUserSignup(email: string) {\n  \"use workflow\";\n\n  const user = await createUser(email);\n  await sendWelcomeEmail(user);\n\n  return { userId: user.id };\n}\n\nasync function createUser(email: string) {\n  \"use step\";\n\n  return { id: crypto.randomUUID(), email };\n}\n```\n\n**Key directives:**\n\n- `\"use workflow\"`: Marks a function as a durable workflow entry point\n- `\"use step\"`: Marks a function as an atomic, retryable step\n\nThese directives trigger the `@workflow/swc-plugin` compiler to transform your code in different ways depending on the execution context.\n\n## [The Three Transformation Modes](https://useworkflow.dev/docs/how-it-works/code-transform\\#the-three-transformation-modes)\n\nThe compiler operates in three distinct modes, transforming the same source code differently for each execution context:\n\nSource Code\n\nwith directives\n\nStep Mode\n\nWorkflow Mode\n\nClient Mode\n\nstep.js\n\n(Step Execution)\n\nflow.js\n\n(Workflow Execution)\n\nYour App Code\n\n(Enables \\`start\\`)\n\n### [Comparison Table](https://useworkflow.dev/docs/how-it-works/code-transform\\#comparison-table)\n\n| Mode | Used In | Purpose | Output API Route | Required? |\n| --- | --- | --- | --- | --- |\n| Step | Build time | Bundles step handlers | `.well-known/workflow/v1/step` | Yes |\n| Workflow | Build time | Bundles workflow orchestrators | `.well-known/workflow/v1/flow` | Yes |\n| Client | Build/Runtime | Provides workflow IDs and types to `start` | Your application code | Optional\\* |\n\n\\\\* Client mode is **recommended** for better developer experience—it provides automatic ID generation and type safety. Without it, you must manually construct workflow IDs or use the build manifest.\n\n## [Detailed Transformation Examples](https://useworkflow.dev/docs/how-it-works/code-transform\\#detailed-transformation-examples)\n\nStep ModeWorkflow ModeClient Mode\n\n**Step Mode** creates the step execution bundle served at `/.well-known/workflow/v1/step`.\n\n**Input:**\n\n```\nexport async function createUser(email: string) {\n  \"use step\";\n  return { id: crypto.randomUUID(), email };\n}\n```\n\n**Output:**\n\n```\nimport { registerStepFunction } from \"workflow/internal/private\";\n\nexport async function createUser(email: string) {\n  return { id: crypto.randomUUID(), email };\n}\n\nregisterStepFunction(\"step//workflows/user.js//createUser\", createUser);\n```\n\n**What happens:**\n\n- The `\"use step\"` directive is removed\n- The function body is kept completely intact (no transformation)\n- The function is registered with the runtime using `registerStepFunction()`\n- Step functions run with full Node.js/Deno/Bun access\n\n**Why no transformation?** Step functions execute in your main runtime with full access to Node.js APIs, file system, databases, etc. They don't need any special handling—they just run normally.\n\n**ID Format:** Step IDs follow the pattern `step//{filepath}//{functionName}`, where the filepath is relative to your project root.\n\n**Workflow Mode** creates the workflow execution bundle served at `/.well-known/workflow/v1/flow`.\n\n**Input:**\n\n```\nexport async function createUser(email: string) {\n  \"use step\";\n  return { id: crypto.randomUUID(), email };\n}\n\nexport async function handleUserSignup(email: string) {\n  \"use workflow\";\n  const user = await createUser(email);\n  return { userId: user.id };\n}\n```\n\n**Output:**\n\n```\nexport async function createUser(email: string) {\n  return globalThis[Symbol.for(\"WORKFLOW_USE_STEP\")](\"step//workflows/user.js//createUser\")(email);\n}\n\nexport async function handleUserSignup(email: string) {\n  const user = await createUser(email);\n  return { userId: user.id };\n}\nhandleUserSignup.workflowId = \"workflow//workflows/user.js//handleUserSignup\";\n```\n\n**What happens:**\n\n- Step function bodies are **replaced** with calls to `globalThis[Symbol.for(\"WORKFLOW_USE_STEP\")]`\n- Workflow function bodies remain **intact**—they execute deterministically during replay\n- The workflow function gets a `workflowId` property for runtime identification\n- The `\"use workflow\"` directive is removed\n\n**Why this transformation?** When a workflow executes, it needs to replay past steps from the [event log](https://useworkflow.dev/docs/how-it-works/event-sourcing) rather than re-executing them. The `WORKFLOW_USE_STEP` symbol is a special runtime hook that:\n\n1. Checks if the step has already been executed (in the event log)\n2. If yes: Returns the cached result\n3. If no: Triggers a suspension and enqueues the step for background execution\n\n**ID Format:** Workflow IDs follow the pattern `workflow//{filepath}//{functionName}`. The `workflowId` property is attached to the function to allow [`start()`](https://useworkflow.dev/docs/api-reference/workflow-api/start) to work at runtime.\n\n**Client Mode** transforms workflow functions in your application code to prevent direct execution.\n\n**Input:**\n\n```\nexport async function handleUserSignup(email: string) {\n  \"use workflow\";\n  const user = await createUser(email);\n  return { userId: user.id };\n}\n```\n\n**Output:**\n\n```\nexport async function handleUserSignup(email: string) {\n  throw new Error(\"You attempted to execute ...\");\n}\nhandleUserSignup.workflowId = \"workflow//workflows/user.js//handleUserSignup\";\n```\n\n**What happens:**\n\n- Workflow function bodies are **replaced** with an error throw\n- The `workflowId` property is added (same as workflow mode)\n- Step functions are not transformed in client mode\n\n**Why this transformation?** Workflow functions cannot be called directly—they must be started using [`start()`](https://useworkflow.dev/docs/api-reference/workflow-api/start). The error prevents accidental direct execution while the `workflowId` property allows the `start()` function to identify which workflow to launch.\n\nThe IDs are generated exactly like in workflow mode to ensure they can be directly referenced at runtime.\n\n**Client mode is optional:** While recommended for better developer experience (automatic IDs and type safety), you can skip client mode and instead:\n\n- Manually construct workflow IDs using the pattern `workflow//{filepath}//{functionName}`\n- Use the workflow manifest file generated during build to lookup IDs\n- Pass IDs directly to `start()` as strings\n\nAll framework integrations include client mode as a loader by default.\n\n## [Generated Files](https://useworkflow.dev/docs/how-it-works/code-transform\\#generated-files)\n\nWhen you build your application, the Workflow DevKit generates three handler files in `.well-known/workflow/v1/`:\n\n### [`flow.js`](https://useworkflow.dev/docs/how-it-works/code-transform\\#flowjs)\n\nContains all workflow functions transformed in **workflow mode**. This file is imported by your framework to handle workflow execution requests at `POST /.well-known/workflow/v1/flow`.\n\n**How it's structured:**\n\nAll workflow code is bundled together and embedded as a string inside `flow.js`. When a workflow needs to execute, this bundled code is run inside a **Node.js VM** (virtual machine) to ensure:\n\n- **Determinism**: The same inputs always produce the same outputs\n- **Side-effect prevention**: Direct access to Node.js APIs, file system, network, etc. is blocked\n- **Sandboxed execution**: Workflow orchestration logic is isolated from the main runtime\n\n**Build-time validation:**\n\nThe workflow mode transformation validates your code during the build:\n\n- Catches invalid Node.js API usage (like `fs`, `http`, `child_process`)\n- Prevents imports of modules that would break determinism\n\nMost invalid patterns cause **build-time errors**, catching issues before deployment.\n\n**What it does:**\n\n- Exports a `POST` handler that accepts Web standard `Request` objects\n- Executes bundled workflow code inside a Node.js VM for each request\n- Handles workflow execution, replay, and resumption\n- Returns execution results to the orchestration layer\n\n**Why a VM?** Workflow functions must be deterministic to support replay. The VM sandbox prevents accidental use of non-deterministic APIs or side effects. All side effects should be performed in [step functions](https://useworkflow.dev/docs/foundations/workflows-and-steps#step-functions) instead.\n\n### [`step.js`](https://useworkflow.dev/docs/how-it-works/code-transform\\#stepjs)\n\nContains all step functions transformed in **step mode**. This file is imported by your framework to handle step execution requests at `POST /.well-known/workflow/v1/step`.\n\n**What it does:**\n\n- Exports a `POST` handler that accepts Web standard `Request` objects\n- Executes individual steps with full runtime access\n- Returns step results to the orchestration layer\n\n### [`webhook.js`](https://useworkflow.dev/docs/how-it-works/code-transform\\#webhookjs)\n\nContains webhook handling logic for delivering external data to running workflows via [`createWebhook()`](https://useworkflow.dev/docs/api-reference/workflow/create-webhook).\n\n**What it does:**\n\n- Exports a `POST` handler that accepts webhook payloads\n- Validates tokens and routes data to the correct workflow run\n- Resumes workflow execution after webhook delivery\n\n**Note:** The webhook file structure varies by framework. Next.js generates `webhook/[token]/route.js` to leverage App Router's dynamic routing, while other frameworks generate a single `webhook.js` or `webhook.mjs` handler.\n\n## [Why Three Modes?](https://useworkflow.dev/docs/how-it-works/code-transform\\#why-three-modes)\n\nThe multi-mode transformation enables the Workflow DevKit's durable execution model:\n\n1. **Step Mode** (required) - Bundles executable step functions that can access the full runtime\n2. **Workflow Mode** (required) - Creates orchestration logic that can replay from event logs\n3. **Client Mode** (optional) - Prevents direct execution and enables type-safe workflow references\n\nThis separation allows:\n\n- **Deterministic replay**: Workflows can be safely replayed from event logs without re-executing side effects\n- **Sandboxed orchestration**: Workflow logic runs in a controlled VM without direct runtime access\n- **Stateless execution**: Your compute can scale to zero and resume from any point in the workflow\n- **Type safety**: TypeScript works seamlessly with workflow references (when using client mode)\n\n## [Determinism and Replay](https://useworkflow.dev/docs/how-it-works/code-transform\\#determinism-and-replay)\n\nA key aspect of the transformation is maintaining **deterministic replay** for workflow functions.\n\n**Workflow functions must be deterministic:**\n\n- Same inputs always produce the same outputs\n- No direct side effects (no API calls, no database writes, no file I/O)\n- Can use seeded random/time APIs provided by the VM (`Math.random()`, `Date.now()`, etc.)\n\nBecause workflow functions are deterministic and have no side effects, they can be safely re-run multiple times to calculate what the next step should be. This is why workflow function bodies remain intact in workflow mode—they're pure orchestration logic.\n\n**Step functions can be non-deterministic:**\n\n- Can make API calls, database queries, etc.\n- Have full access to Node.js runtime and APIs\n- Results are cached in the [event log](https://useworkflow.dev/docs/how-it-works/event-sourcing) after first execution\n\nLearn more about [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps).\n\n## [ID Generation](https://useworkflow.dev/docs/how-it-works/code-transform\\#id-generation)\n\nThe compiler generates stable IDs for workflows and steps based on file paths and function names:\n\n**Pattern:**`{type}//{filepath}//{functionName}`\n\n**Examples:**\n\n- `workflow//workflows/user-signup.js//handleUserSignup`\n- `step//workflows/user-signup.js//createUser`\n- `step//workflows/payments/checkout.ts//processPayment`\n\n**Key properties:**\n\n- **Stable**: IDs don't change unless you rename files or functions\n- **Unique**: Each workflow/step has a unique identifier\n- **Portable**: Works across different runtimes and deployments\n\nAlthough IDs can change when files are moved or functions are renamed, Workflow DevKit function assume atomic versioning in the World. This means changing IDs won't break old workflows from running, but will prevent run from being upgraded and will cause your workflow/step names to change in the observability across deployments.\n\n## [Framework Integration](https://useworkflow.dev/docs/how-it-works/code-transform\\#framework-integration)\n\nThese transformations are framework-agnostic—they output standard JavaScript that works anywhere.\n\n**For users**: Your framework handles all transformations automatically. See the [Getting Started](https://useworkflow.dev/docs/getting-started) guide for your framework.\n\n**For framework authors**: Learn how to integrate these transformations into your framework in [Building Framework Integrations](https://useworkflow.dev/docs/how-it-works/framework-integrations).\n\n## [Debugging Transformed Code](https://useworkflow.dev/docs/how-it-works/code-transform\\#debugging-transformed-code)\n\nIf you need to debug transformation issues, you can inspect the generated files:\n\n1. **Look in `.well-known/workflow/v1/`**: Check the generated `flow.js`, `step.js`,`webhook.js`, and other emitted debug files.\n2. **Check build logs**: Most frameworks log transformation activity during builds\n3. **Verify directives**: Ensure `\"use workflow\"` and `\"use step\"` are the first statements in functions\n4. **Check file locations**: Transformations only apply to files in configured source directories\n\n[Understanding Directives\\\\\n\\\\\nPrevious Page](https://useworkflow.dev/docs/how-it-works/understanding-directives) [Framework Integrations\\\\\n\\\\\nNext Page](https://useworkflow.dev/docs/how-it-works/framework-integrations)\n\nOn this page\n\n[Directives Overview](https://useworkflow.dev/docs/how-it-works/code-transform#directives-overview) [The Three Transformation Modes](https://useworkflow.dev/docs/how-it-works/code-transform#the-three-transformation-modes) [Comparison Table](https://useworkflow.dev/docs/how-it-works/code-transform#comparison-table) [Detailed Transformation Examples](https://useworkflow.dev/docs/how-it-works/code-transform#detailed-transformation-examples) [Generated Files](https://useworkflow.dev/docs/how-it-works/code-transform#generated-files) [`flow.js`](https://useworkflow.dev/docs/how-it-works/code-transform#flowjs) [`step.js`](https://useworkflow.dev/docs/how-it-works/code-transform#stepjs) [`webhook.js`](https://useworkflow.dev/docs/how-it-works/code-transform#webhookjs) [Why Three Modes?](https://useworkflow.dev/docs/how-it-works/code-transform#why-three-modes) [Determinism and Replay](https://useworkflow.dev/docs/how-it-works/code-transform#determinism-and-replay) [ID Generation](https://useworkflow.dev/docs/how-it-works/code-transform#id-generation) [Framework Integration](https://useworkflow.dev/docs/how-it-works/code-transform#framework-integration) [Debugging Transformed Code](https://useworkflow.dev/docs/how-it-works/code-transform#debugging-transformed-code)\n\n[GitHubEdit this page on GitHub](https://github.com/vercel/workflow/edit/main/content/docs/how-it-works/code-transform.mdx) Scroll to topGive feedbackCopy pageAsk AI about this pageOpen in chat\n\n## Chat\n\nWhat is Workflow?How does retrying work?What control flow patterns are there?How do directives work?How do I build an AI agent?\n\nTip: You can open and close chat with `⌘I`\n\n0 / 1000",
  "metadata": {
    "twitter:image:height": "628",
    "viewport": "width=device-width, initial-scale=1",
    "ogTitle": "How the Directives Work",
    "og:image:height": "628",
    "twitter:card": "summary_large_image",
    "twitter:image:type": "image/png",
    "twitter:title": "How the Directives Work",
    "ogImage": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "next-size-adjust": "",
    "og:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "twitter:image:width": "1200",
    "og:title": "How the Directives Work",
    "language": "en",
    "og:image:width": "1200",
    "twitter:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "title": "How the Directives Work",
    "og:image:type": "image/png",
    "favicon": "https://useworkflow.dev/favicon.ico?favicon.e7ce0d1c.ico",
    "scrapeId": "019bf2d4-569c-75d7-940f-b38a86de6987",
    "sourceURL": "https://useworkflow.dev/docs/how-it-works/code-transform",
    "url": "https://useworkflow.dev/docs/how-it-works/code-transform",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic",
    "cacheState": "hit",
    "cachedAt": "2026-01-24T22:01:01.591Z",
    "creditsUsed": 1
  }
}