{
  "markdown": "[Vercel](https://vercel.com/) Slash [Workflow DevKit LogoWorkflow](https://useworkflow.dev/)\n\n- [Docs](https://useworkflow.dev/docs)\n- [Examples](https://github.com/vercel/workflow-examples)\n\n[X](https://x.com/workflowdevkit) [GitHub](https://github.com/vercel/workflow) Search... `⌘K`Ask AI\n\nAsk AI\n\nSearch... `⌘K`\n\n[Getting Started](https://useworkflow.dev/docs/getting-started)\n\n- [Next.js](https://useworkflow.dev/docs/getting-started/next)\n- [Vite](https://useworkflow.dev/docs/getting-started/vite)\n- [Astro](https://useworkflow.dev/docs/getting-started/astro)\n- [Express](https://useworkflow.dev/docs/getting-started/express)\n- [Fastify](https://useworkflow.dev/docs/getting-started/fastify)\n- [Hono](https://useworkflow.dev/docs/getting-started/hono)\n- [Nitro](https://useworkflow.dev/docs/getting-started/nitro)\n- [Nuxt](https://useworkflow.dev/docs/getting-started/nuxt)\n- [SvelteKit](https://useworkflow.dev/docs/getting-started/sveltekit)\n\n[Foundations](https://useworkflow.dev/docs/foundations)\n\n- [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps)\n- [Starting Workflows](https://useworkflow.dev/docs/foundations/starting-workflows)\n- [Control Flow Patterns](https://useworkflow.dev/docs/foundations/control-flow-patterns)\n- [Errors & Retrying](https://useworkflow.dev/docs/foundations/errors-and-retries)\n- [Hooks & Webhooks](https://useworkflow.dev/docs/foundations/hooks)\n- [Streaming](https://useworkflow.dev/docs/foundations/streaming)\n- [Serialization](https://useworkflow.dev/docs/foundations/serialization)\n- [Idempotency](https://useworkflow.dev/docs/foundations/idempotency)\n\nHow it works\n\n[Observability](https://useworkflow.dev/docs/observability)\n\nAI Agents\n\n- [Building Durable AI Agents](https://useworkflow.dev/docs/ai)\n- [Streaming Updates from Tools](https://useworkflow.dev/docs/ai/streaming-updates-from-tools)\n- [Resumable Streams](https://useworkflow.dev/docs/ai/resumable-streams)\n- [Sleep, Suspense, and Scheduling](https://useworkflow.dev/docs/ai/sleep-and-delays)\n- [Human-in-the-Loop](https://useworkflow.dev/docs/ai/human-in-the-loop)\n- [Patterns for Defining Tools](https://useworkflow.dev/docs/ai/defining-tools)\n- [Chat Session Modeling](https://useworkflow.dev/docs/ai/chat-session-modeling)\n\n[Deploying](https://useworkflow.dev/docs/deploying)\n\n[Errors](https://useworkflow.dev/docs/errors)\n\n[API Reference](https://useworkflow.dev/docs/api-reference)\n\nHooks & WebhooksUnderstanding Hooks\n\n[Foundations](https://useworkflow.dev/docs/foundations)\n\n# Hooks & Webhooks\n\nHooks provide a powerful mechanism for pausing workflow execution and resuming it later with external data. They enable workflows to wait for external events, user interactions (also known as \"human in the loop\"), or HTTP requests. This guide will teach you the core concepts, starting with the low-level Hook primitive and building up to the higher-level Webhook abstraction.\n\n## [Understanding Hooks](https://useworkflow.dev/docs/foundations/hooks\\#understanding-hooks)\n\nAt their core, **Hooks** are a low-level primitive that allows you to pause a workflow and resume it later with arbitrary [serializable data](https://useworkflow.dev/docs/foundations/serialization). Think of them as suspension points in your workflow where you're waiting for external input.\n\nWhen you create a hook, it generates a unique token that external systems can use to send data back to your workflow. This makes hooks perfect for scenarios like:\n\n- Waiting for approval from a user or admin\n- Receiving data from an external system or service\n- Implementing event-driven workflows that react to multiple events over time\n\n### [Creating Your First Hook](https://useworkflow.dev/docs/foundations/hooks\\#creating-your-first-hook)\n\nLet's start with a simple example. Here's a workflow that creates a hook and waits for external data:\n\n```\nimport { createHook } from \"workflow\";\n\nexport async function approvalWorkflow() {\n  \"use workflow\";\n\n  // Create a hook that expects an approval payload\n  const hook = createHook<{ approved: boolean; comment: string }>();\n\n  console.log(\"Waiting for approval...\");\n  console.log(\"Send approval to token:\", hook.token);\n\n  // Workflow pauses here until data is sent\n  const result = await hook;\n\n  if (result.approved) {\n    console.log(\"Approved with comment:\", result.comment);\n    // Continue with approved workflow...\n  } else {\n    console.log(\"Rejected:\", result.comment);\n    // Handle rejection...\n  }\n}\n```\n\nThe workflow will pause at `await hook` until external code sends data to resume it.\n\nSee the full API reference for [`createHook()`](https://useworkflow.dev/docs/api-reference/workflow/create-hook) for all available options.\n\n### [Resuming a Hook](https://useworkflow.dev/docs/foundations/hooks\\#resuming-a-hook)\n\nTo send data to a waiting workflow, use [`resumeHook()`](https://useworkflow.dev/docs/api-reference/workflow-api/resume-hook) from an API route, server action, or any other external context:\n\n```\nimport { resumeHook } from \"workflow/api\";\n\n// In an API route or external handler\nexport async function POST(request: Request) {\n  const { token, approved, comment } = await request.json();\n\n  try {\n    // Resume the workflow with the approval data\n    const result = await resumeHook(token, { approved, comment });\n    return Response.json({ success: true, runId: result.runId });\n  } catch (error) {\n    return Response.json({ error: \"Invalid token\" }, { status: 404 });\n  }\n}\n```\n\nThe key points:\n\n- Hooks allow you to pass **any [serializable data](https://useworkflow.dev/docs/foundations/serialization)** as the payload\n- You need the hook's `token` to resume it\n- The workflow will resume execution right where it left off\n\n### [Custom Tokens for Deterministic Hooks](https://useworkflow.dev/docs/foundations/hooks\\#custom-tokens-for-deterministic-hooks)\n\nBy default, hooks generate a random token. However, you often want to use a **custom token** that external systems can reconstruct. This is especially useful for long-running workflows where the same workflow instance should handle multiple events.\n\nFor example, imagine a Slack bot where each channel should have its own workflow instance:\n\n```\nimport { createHook } from \"workflow\";\n\nexport async function slackChannelBot(channelId: string) {\n  \"use workflow\";\n\n  // Use channel ID in the token so Slack webhooks can find this workflow\n  const hook = createHook<SlackMessage>({\n    token: `slack_messages:${channelId}`\n  });\n\n  for await (const message of hook) {\n    console.log(`${message.user}: ${message.text}`);\n\n    if (message.text === \"/stop\") {\n      break;\n    }\n\n    await processMessage(message);\n  }\n}\n\nasync function processMessage(message: SlackMessage) {\n  \"use step\";\n  // Process the Slack message\n}\n```\n\nNow your Slack webhook handler can deterministically resume the correct workflow:\n\n```\nimport { resumeHook } from \"workflow/api\";\n\nexport async function POST(request: Request) {\n  const slackEvent = await request.json();\n  const channelId = slackEvent.channel;\n\n  try {\n    // Reconstruct the token using the channel ID\n    await resumeHook(`slack_messages:${channelId}`, slackEvent);\n\n    return new Response(\"OK\");\n  } catch (error) {\n    return new Response(\"Hook not found\", { status: 404 });\n  }\n}\n```\n\n### [Receiving Multiple Events](https://useworkflow.dev/docs/foundations/hooks\\#receiving-multiple-events)\n\nHooks are _reusable_ \\- they implement `AsyncIterable`, which means you can use `for await...of` to receive multiple events over time:\n\n```\nimport { createHook } from \"workflow\";\n\nexport async function dataCollectionWorkflow() {\n  \"use workflow\";\n\n  const hook = createHook<{ value: number; done?: boolean }>();\n\n  const values: number[] = [];\n\n  // Keep receiving data until we get a \"done\" signal\n  for await (const payload of hook) {\n    values.push(payload.value);\n\n    if (payload.done) {\n      break;\n    }\n  }\n\n  console.log(\"Collected values:\", values);\n  return values;\n}\n```\n\nEach time you call `resumeHook()` with the same token, the loop receives another value.\n\n## [Understanding Webhooks](https://useworkflow.dev/docs/foundations/hooks\\#understanding-webhooks)\n\nWhile hooks are powerful, they require you to manually handle HTTP requests and route them to workflows. **Webhooks** solve this by providing a higher-level abstraction built on top of hooks that:\n\n1. Automatically serializes the entire HTTP [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object\n2. Provides an automatically addressable `url` property pointing to the generated webhook endpoint\n3. Handles sending HTTP [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects back to the caller\n\nWhen using Workflow DevKit, webhooks are automatically wired up at `/.well-known/workflow/v1/webhook/:token` without any additional setup.\n\nSee the full API reference for [`createWebhook()`](https://useworkflow.dev/docs/api-reference/workflow/create-webhook) for all available options.\n\n### [Creating Your First Webhook](https://useworkflow.dev/docs/foundations/hooks\\#creating-your-first-webhook)\n\nHere's a simple webhook that receives HTTP requests:\n\n```\nimport { createWebhook } from \"workflow\";\n\nexport async function webhookWorkflow() {\n  \"use workflow\";\n\n  const webhook = createWebhook();\n\n  // The webhook is automatically available at this URL\n  console.log(\"Send HTTP requests to:\", webhook.url);\n  // Example: https://your-app.com/.well-known/workflow/v1/webhook/lJHkuMdQ2FxSFTbUMU84k\n\n  // Workflow pauses until an HTTP request is received\n  const request = await webhook;\n\n  console.log(\"Received request:\", request.method, request.url);\n\n  // Access the request body\n  const data = await request.json();\n  console.log(\"Data:\", data);\n}\n```\n\nThe webhook will automatically respond with a `202 Accepted` status by default. External systems can simply make an HTTP request to the `webhook.url` to resume your workflow.\n\n### [Sending Custom Responses](https://useworkflow.dev/docs/foundations/hooks\\#sending-custom-responses)\n\nWebhooks provide two ways to send custom HTTP responses: **static responses** and **dynamic responses**.\n\n#### [Static Responses](https://useworkflow.dev/docs/foundations/hooks\\#static-responses)\n\nUse the `respondWith` option to provide a static response that will be sent automatically for every request:\n\n```\nimport { createWebhook } from \"workflow\";\n\nexport async function webhookWithStaticResponse() {\n  \"use workflow\";\n\n  const webhook = createWebhook({\n    respondWith: Response.json({\n      success: true, message: \"Webhook received\"\n    }),\n  });\n\n  const request = await webhook;\n\n  // The response was already sent automatically\n  // Continue processing the request asynchronously\n  const data = await request.json();\n  await processData(data);\n}\n\nasync function processData(data: any) {\n  \"use step\";\n  // Long-running processing here\n}\n```\n\n#### [Dynamic Responses (Manual Mode)](https://useworkflow.dev/docs/foundations/hooks\\#dynamic-responses-manual-mode)\n\nFor dynamic responses based on the request content, set `respondWith: \"manual\"` and call the `respondWith()` method on the request:\n\n```\nimport { createWebhook, type RequestWithResponse } from \"workflow\";\n\nasync function sendCustomResponse(request: RequestWithResponse, message: string) {\n  \"use step\";\n\n  // Call respondWith() to send the response\n  await request.respondWith(\n    new Response(\n      JSON.stringify({ message }),\n      {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" }\n      }\n    )\n  );\n}\n\nexport async function webhookWithDynamicResponse() {\n  \"use workflow\";\n\n  // Set respondWith to \"manual\" to handle responses yourself\n  const webhook = createWebhook({ respondWith: \"manual\" });\n\n  const request = await webhook;\n  const data = await request.json();\n\n  // Decide what response to send based on the data\n  if (data.type === \"urgent\") {\n    await sendCustomResponse(request, \"Processing urgently\");\n  } else {\n    await sendCustomResponse(request, \"Processing normally\");\n  }\n\n  // Continue workflow...\n}\n```\n\nWhen using `respondWith: \"manual\"`, the `respondWith()` method **must** be called from within a step function due to serialization requirements. This requirement may be removed in the future.\n\n### [Handling Multiple Webhook Requests](https://useworkflow.dev/docs/foundations/hooks\\#handling-multiple-webhook-requests)\n\nLike hooks, webhooks support iteration:\n\n```\nimport { createWebhook, type RequestWithResponse } from \"workflow\";\n\nasync function respondToSlack(request: RequestWithResponse, text: string) {\n  \"use step\";\n\n  await request.respondWith(\n    new Response(\n      JSON.stringify({ response_type: \"in_channel\", text }),\n      { headers: { \"Content-Type\": \"application/json\" } }\n    )\n  );\n}\n\nexport async function slackCommandWorkflow(channelId: string) {\n  \"use workflow\";\n\n  const webhook = createWebhook({\n    token: `slack_command:${channelId}`,\n    respondWith: \"manual\"\n  });\n\n  console.log(\"Configure Slack command webhook:\", webhook.url);\n\n  for await (const request of webhook) {\n    const formData = await request.formData();\n    const command = formData.get(\"command\");\n    const text = formData.get(\"text\");\n\n    if (command === \"/status\") {\n      await respondToSlack(request, \"Checking status...\");\n      const status = await checkSystemStatus();\n      await postToSlack(channelId, `Status: ${status}`);\n    }\n\n    if (text === \"stop\") {\n      await respondToSlack(request, \"Stopping workflow...\");\n      break;\n    }\n  }\n}\n\nasync function checkSystemStatus() {\n  \"use step\";\n  return \"All systems operational\";\n}\n\nasync function postToSlack(channelId: string, message: string) {\n  \"use step\";\n  // Post message to Slack\n}\n```\n\n## [Hooks vs. Webhooks: When to Use Each](https://useworkflow.dev/docs/foundations/hooks\\#hooks-vs-webhooks-when-to-use-each)\n\n| Feature | Hooks | Webhooks |\n| --- | --- | --- |\n| **Data Format** | Arbitrary serializable data | HTTP `Request` objects |\n| **URL** | No automatic URL | Automatic `webhook.url` property |\n| **Response Handling** | N/A | Can send HTTP `Response` (static or dynamic) |\n| **Use Case** | Custom integrations, type-safe payloads | HTTP webhooks, standard REST APIs |\n| **Resuming** | [`resumeHook()`](https://useworkflow.dev/docs/api-reference/workflow-api/resume-hook) | Automatic via HTTP, or [`resumeWebhook()`](https://useworkflow.dev/docs/api-reference/workflow-api/resume-webhook) |\n\n**Use Hooks when:**\n\n- You need full control over the payload structure\n- You're integrating with custom event sources\n- You want strong TypeScript typing with [`defineHook()`](https://useworkflow.dev/docs/api-reference/workflow/define-hook)\n\n**Use Webhooks when:**\n\n- You're receiving HTTP requests from external services\n- You need to send HTTP responses back to the caller\n- You want automatic URL routing without writing API handlers\n\n## [Advanced Patterns](https://useworkflow.dev/docs/foundations/hooks\\#advanced-patterns)\n\n### [Type-Safe Hooks with `defineHook()`](https://useworkflow.dev/docs/foundations/hooks\\#type-safe-hooks-with-definehook)\n\nThe [`defineHook()`](https://useworkflow.dev/docs/api-reference/workflow/define-hook) helper provides type safety and runtime validation between creating and resuming hooks using [Standard Schema v1](https://standardschema.dev/). Use any compliant validator like Zod or Valibot:\n\n```\nimport { defineHook } from \"workflow\";\nimport { z } from \"zod\";\n\n// Define the hook with schema for type safety and runtime validation\nconst approvalHook = defineHook({\n  schema: z.object({\n    requestId: z.string(),\n    approved: z.boolean(),\n    approvedBy: z.string(),\n    comment: z.string().transform((value) => value.trim()),\n  }),\n});\n\n// In your workflow\nexport async function documentApprovalWorkflow(documentId: string) {\n  \"use workflow\";\n\n  const hook = approvalHook.create({\n    token: `approval:${documentId}`\n  });\n\n  // Payload is type-safe and validated\n  const approval = await hook;\n\n  console.log(`Document ${approval.requestId} ${approval.approved ? \"approved\" : \"rejected\"}`);\n  console.log(`By: ${approval.approvedBy}, Comment: ${approval.comment}`);\n}\n\n// In your API route - both type-safe and runtime-validated!\nexport async function POST(request: Request) {\n  const { documentId, ...approvalData } = await request.json();\n\n  try {\n    // The schema validates the payload before resuming the workflow\n    await approvalHook.resume(`approval:${documentId}`, approvalData);\n    return new Response(\"OK\");\n  } catch (error) {\n    return Response.json({ error: \"Invalid token or validation failed\" }, { status: 400 });\n  }\n}\n```\n\nThis pattern is especially valuable in larger applications where the workflow and API code are in separate files, providing both compile-time type safety and runtime validation.\n\n## [Best Practices](https://useworkflow.dev/docs/foundations/hooks\\#best-practices)\n\n### [Token Design](https://useworkflow.dev/docs/foundations/hooks\\#token-design)\n\nWhen using custom tokens:\n\n- **Make them deterministic**: Base them on data the external system can reconstruct (like channel IDs, user IDs, etc.)\n- **Use namespacing**: Prefix tokens to avoid conflicts (e.g., `slack:${channelId}`, `github:${repoId}`)\n- **Include routing information**: Ensure the token contains enough information to identify the correct workflow instance\n\n### [Response Handling in Webhooks](https://useworkflow.dev/docs/foundations/hooks\\#response-handling-in-webhooks)\n\n- Use **static responses** (`respondWith: Response`) for simple acknowledgments\n- Use **manual mode** (`respondWith: \"manual\"`) when responses depend on request processing\n- Remember that `respondWith()` must be called from within a step function\n\n### [Iterating Over Events](https://useworkflow.dev/docs/foundations/hooks\\#iterating-over-events)\n\nBoth hooks and webhooks support iteration, making them perfect for long-running event loops:\n\n```\nconst hook = createHook<Event>();\n\nfor await (const event of hook) {\n  await processEvent(event);\n\n  if (shouldStop(event)) {\n    break;\n  }\n}\n```\n\nThis pattern allows a single workflow instance to handle multiple events over time, maintaining state between events.\n\n## [Related Documentation](https://useworkflow.dev/docs/foundations/hooks\\#related-documentation)\n\n- [Serialization](https://useworkflow.dev/docs/foundations/serialization) \\- Understanding what data can be passed through hooks\n- [`createHook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow/create-hook)\n- [`createWebhook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow/create-webhook)\n- [`defineHook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow/define-hook)\n- [`resumeHook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow-api/resume-hook)\n- [`resumeWebhook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow-api/resume-webhook)\n\n[Errors & Retrying\\\\\n\\\\\nPrevious Page](https://useworkflow.dev/docs/foundations/errors-and-retries) [Streaming\\\\\n\\\\\nNext Page](https://useworkflow.dev/docs/foundations/streaming)\n\nOn this page\n\n[Understanding Hooks](https://useworkflow.dev/docs/foundations/hooks#understanding-hooks) [Creating Your First Hook](https://useworkflow.dev/docs/foundations/hooks#creating-your-first-hook) [Resuming a Hook](https://useworkflow.dev/docs/foundations/hooks#resuming-a-hook) [Custom Tokens for Deterministic Hooks](https://useworkflow.dev/docs/foundations/hooks#custom-tokens-for-deterministic-hooks) [Receiving Multiple Events](https://useworkflow.dev/docs/foundations/hooks#receiving-multiple-events) [Understanding Webhooks](https://useworkflow.dev/docs/foundations/hooks#understanding-webhooks) [Creating Your First Webhook](https://useworkflow.dev/docs/foundations/hooks#creating-your-first-webhook) [Sending Custom Responses](https://useworkflow.dev/docs/foundations/hooks#sending-custom-responses) [Static Responses](https://useworkflow.dev/docs/foundations/hooks#static-responses) [Dynamic Responses (Manual Mode)](https://useworkflow.dev/docs/foundations/hooks#dynamic-responses-manual-mode) [Handling Multiple Webhook Requests](https://useworkflow.dev/docs/foundations/hooks#handling-multiple-webhook-requests) [Hooks vs. Webhooks: When to Use Each](https://useworkflow.dev/docs/foundations/hooks#hooks-vs-webhooks-when-to-use-each) [Advanced Patterns](https://useworkflow.dev/docs/foundations/hooks#advanced-patterns) [Type-Safe Hooks with `defineHook()`](https://useworkflow.dev/docs/foundations/hooks#type-safe-hooks-with-definehook) [Best Practices](https://useworkflow.dev/docs/foundations/hooks#best-practices) [Token Design](https://useworkflow.dev/docs/foundations/hooks#token-design) [Response Handling in Webhooks](https://useworkflow.dev/docs/foundations/hooks#response-handling-in-webhooks) [Iterating Over Events](https://useworkflow.dev/docs/foundations/hooks#iterating-over-events) [Related Documentation](https://useworkflow.dev/docs/foundations/hooks#related-documentation)\n\n[GitHubEdit this page on GitHub](https://github.com/vercel/workflow/edit/main/content/docs/foundations/hooks.mdx) Scroll to topGive feedbackCopy pageAsk AI about this pageOpen in chat\n\n## Chat\n\nWhat is Workflow?How does retrying work?What control flow patterns are there?How do directives work?How do I build an AI agent?\n\nTip: You can open and close chat with `⌘I`\n\n0 / 1000",
  "metadata": {
    "twitter:card": "summary_large_image",
    "next-size-adjust": "",
    "title": "Hooks & Webhooks",
    "twitter:image:type": "image/png",
    "twitter:title": "Hooks & Webhooks",
    "twitter:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "ogTitle": "Hooks & Webhooks",
    "ogImage": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "language": "en",
    "viewport": "width=device-width, initial-scale=1",
    "og:image:height": "628",
    "twitter:image:width": "1200",
    "og:image:type": "image/png",
    "og:image:width": "1200",
    "og:title": "Hooks & Webhooks",
    "og:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "twitter:image:height": "628",
    "favicon": "https://useworkflow.dev/favicon.ico?favicon.e7ce0d1c.ico",
    "scrapeId": "019bf2d4-569c-75d7-940f-cd2d824bec8b",
    "sourceURL": "https://useworkflow.dev/docs/foundations/hooks",
    "url": "https://useworkflow.dev/docs/foundations/hooks",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic",
    "cacheState": "hit",
    "cachedAt": "2026-01-24T22:01:05.620Z",
    "creditsUsed": 1
  }
}