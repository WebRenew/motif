{
  "markdown": "[Vercel](https://vercel.com/) Slash [Workflow DevKit LogoWorkflow](https://useworkflow.dev/)\n\n- [Docs](https://useworkflow.dev/docs)\n- [Examples](https://github.com/vercel/workflow-examples)\n\n[X](https://x.com/workflowdevkit) [GitHub](https://github.com/vercel/workflow) Search... `⌘K`Ask AI\n\nAsk AI\n\nSearch... `⌘K`\n\n[Getting Started](https://useworkflow.dev/docs/getting-started)\n\n- [Next.js](https://useworkflow.dev/docs/getting-started/next)\n- [Vite](https://useworkflow.dev/docs/getting-started/vite)\n- [Astro](https://useworkflow.dev/docs/getting-started/astro)\n- [Express](https://useworkflow.dev/docs/getting-started/express)\n- [Fastify](https://useworkflow.dev/docs/getting-started/fastify)\n- [Hono](https://useworkflow.dev/docs/getting-started/hono)\n- [Nitro](https://useworkflow.dev/docs/getting-started/nitro)\n- [Nuxt](https://useworkflow.dev/docs/getting-started/nuxt)\n- [SvelteKit](https://useworkflow.dev/docs/getting-started/sveltekit)\n\n[Foundations](https://useworkflow.dev/docs/foundations)\n\n- [Workflows and Steps](https://useworkflow.dev/docs/foundations/workflows-and-steps)\n- [Starting Workflows](https://useworkflow.dev/docs/foundations/starting-workflows)\n- [Control Flow Patterns](https://useworkflow.dev/docs/foundations/control-flow-patterns)\n- [Errors & Retrying](https://useworkflow.dev/docs/foundations/errors-and-retries)\n- [Hooks & Webhooks](https://useworkflow.dev/docs/foundations/hooks)\n- [Streaming](https://useworkflow.dev/docs/foundations/streaming)\n- [Serialization](https://useworkflow.dev/docs/foundations/serialization)\n- [Idempotency](https://useworkflow.dev/docs/foundations/idempotency)\n\nHow it works\n\n[Observability](https://useworkflow.dev/docs/observability)\n\nAI Agents\n\n- [Building Durable AI Agents](https://useworkflow.dev/docs/ai)\n- [Streaming Updates from Tools](https://useworkflow.dev/docs/ai/streaming-updates-from-tools)\n- [Resumable Streams](https://useworkflow.dev/docs/ai/resumable-streams)\n- [Sleep, Suspense, and Scheduling](https://useworkflow.dev/docs/ai/sleep-and-delays)\n- [Human-in-the-Loop](https://useworkflow.dev/docs/ai/human-in-the-loop)\n- [Patterns for Defining Tools](https://useworkflow.dev/docs/ai/defining-tools)\n- [Chat Session Modeling](https://useworkflow.dev/docs/ai/chat-session-modeling)\n\n[Deploying](https://useworkflow.dev/docs/deploying)\n\n[Errors](https://useworkflow.dev/docs/errors)\n\n[API Reference](https://useworkflow.dev/docs/api-reference)\n\nChat Session ModelingSingle-Turn Workflows\n\nAI Agents\n\n# Chat Session Modeling\n\nChat sessions in AI agents can be modeled at different layers of your architecture. The choice affects state ownership and how you handle interruptions and reconnections.\n\nWhile there are many ways to model chat sessions, the two most common categories are single-turn and multi-turn.\n\n## [Single-Turn Workflows](https://useworkflow.dev/docs/ai/chat-session-modeling\\#single-turn-workflows)\n\nEach user message triggers a new workflow run. The client or API route owns the conversation history and sends the full message array with each request.\n\nWorkflowAPI RouteClient\n\nworkflows/chat/index.ts\n\n```\n\n```\n\napp/api/chat/route.ts\n\n```\n\n```\n\nChat messages need to be stored somewhere—typically a database. In this example, we assume a route like `/chats/:id` passes the session ID, allowing us to fetch existing messages and persist new ones.\n\napp/chats/\\[id\\]/page.tsx\n\n```\n\n```\n\nThis is the pattern used in the [Building Durable AI Agents](https://useworkflow.dev/docs/ai) guide.\n\nIn this pattern, the client owns conversation state, with the latest turn managed by the AI SDK's `useChat`, and past turns persisted to a user-managed database.\n\nPersisting the turn is usually done through either:\n\n- A step on the workflow that runs after `agent.stream()` and takes the message history from the agent return value (either `messages: ModelMessage[]` or `uiMessages: UIMessage[]`)\n- A hook on `useChat`in the client that calls an API to persist state (or localStorage, etc.), either on every new message, or `onFinish`\n- The resumable stream attached to the workflow (see [Resumable Streams](https://useworkflow.dev/docs/ai/resumable-streams))\n  - Note that user messages are not persisted to the stream by default, and need to be explicitly persisted separately\n\n## [Multi-Turn Workflows](https://useworkflow.dev/docs/ai/chat-session-modeling\\#multi-turn-workflows)\n\nA single workflow handles the entire conversation session across multiple turns, and owns the current conversation state. The clients/API routes inject new messages via hooks. The workflow run ID serves as the session identifier.\n\nFor a full example of an agent using multi-turn workflows, check out the Flight Booking App example in the [Workflow Examples](https://github.com/vercel/workflow-examples/tree/main/flight-booking-app) repository.\n\nA key challenge in multi-turn workflows is ensuring user messages appear in the correct order when replaying the stream (e.g., after a page refresh). Since the stream primarily contains AI responses, user messages must be explicitly marked in the stream so the client can reconstruct the full conversation.\n\nWorkflowAPI RoutesHook DefinitionClient Hook\n\nworkflows/chat/index.ts\n\n```\n\n```\n\nThe `writeUserMessageMarker` helper writes a `data-workflow` chunk to mark user turns:\n\nworkflows/chat/steps/writer.ts\n\n```\n\n```\n\nThree endpoints: start a session, send follow-up messages, and reconnect to the stream.\n\napp/api/chat/route.ts\n\n```\n\n```\n\napp/api/chat/\\[id\\]/route.ts\n\n```\n\n```\n\napp/api/chat/\\[id\\]/stream/route.ts\n\n```\n\n```\n\nworkflows/chat/hooks/chat-message.ts\n\n```\n\n```\n\nA custom hook wraps `useChat` to manage the multi-turn session. It handles:\n\n- Routing between the initial message endpoint and follow-up endpoint\n- Reconstructing user messages from stream markers for correct ordering on replay\n\nhooks/use-multi-turn-chat.ts\n\n```\n\n```\n\nIn this pattern, the workflow owns the entire conversation session. All messages are persisted in the workflow, and follow-up messages are injected via hooks. The workflow writes **user message markers** to the stream using `data-workflow` chunks, which allows the client to reconstruct the full conversation in the correct order when replaying the stream (e.g., after a page refresh).\n\nThe client hook processes these markers by:\n\n1. Iterating through message parts in order\n2. When a `user-message` marker is found, flushing any accumulated assistant content and inserting the user message\n3. Deduplicating against optimistic sends from the initial message\n\nThis ensures the conversation displays as User → AI → User → AI regardless of whether viewing live or replaying from the stream.\n\n## [Choosing a Pattern](https://useworkflow.dev/docs/ai/chat-session-modeling\\#choosing-a-pattern)\n\n| Consideration | Single-Turn | Multi-Turn |\n| --- | --- | --- |\n| State ownership | Client or API route | Workflow |\n| Message injection from backend | Requires stitching together runs | Native via hooks |\n| Workflow complexity | Lower | Higher |\n| Workflow time horizon | Minutes | Hours to indefinitely |\n| Observability scope | Per-turn traces | Full session traces |\n\n**Multi-turn is recommended for most production use-cases.** If you're starting fresh, go with multi-turn. It's more flexible and grows with your requirements. You don't need to maintain the chat history yourself and can offload all that to the workflow's built in persistence. It also enables native message injection and full session observability, which becomes increasingly valuable as your agent matures.\n\n**Single-turn works well when adapting existing architectures.** If you already have a system for managing message state, and want to adopt durable agents incrementally, single-turn workflows slot in with minimal changes. Each turn maps cleanly to an independent workflow run.\n\n## [Multiplayer Chat Sessions](https://useworkflow.dev/docs/ai/chat-session-modeling\\#multiplayer-chat-sessions)\n\nThe multi-turn pattern also easily enables multi-player chat sessions. New messages can come from system events, external services, and other users. Since a `hook` injects messages into workflow at any point, and the entire history is a single stream that clients can reconnect to, it doesn't matter where the injected messages come from. Here are different use-cases for multi-player chat sessions:\n\nSystem EventExternal ServiceMultiple Users\n\nInternal system events like scheduled tasks, background jobs, or database triggers can inject updates into an active conversation.\n\napp/api/internal/flight-update/route.ts\n\n```\n\n```\n\nExternal webhooks from third-party services (Stripe, Twilio, etc.) can notify the conversation of events.\n\napp/api/webhooks/payment/route.ts\n\n```\n\n```\n\nMultiple human users can participate in the same conversation. Each user's client connects to the same workflow stream.\n\napp/api/chat/\\[id\\]/route.ts\n\n```\n\n```\n\n## [Related Documentation](https://useworkflow.dev/docs/ai/chat-session-modeling\\#related-documentation)\n\n- [Building Durable AI Agents](https://useworkflow.dev/docs/ai) \\- Foundation guide for durable agents\n- [Message Queueing](https://useworkflow.dev/docs/ai/message-queueing) \\- Queueing messages during tool execution\n- [`defineHook()` API Reference](https://useworkflow.dev/docs/api-reference/workflow/define-hook) \\- Hook configuration options\n- [`DurableAgent` API Reference](https://useworkflow.dev/docs/api-reference/workflow-ai/durable-agent) \\- Full API documentation\n\n[Patterns for Defining Tools\\\\\n\\\\\nPrevious Page](https://useworkflow.dev/docs/ai/defining-tools) [Deploying\\\\\n\\\\\nNext Page](https://useworkflow.dev/docs/deploying)\n\nOn this page\n\n[Single-Turn Workflows](https://useworkflow.dev/docs/ai/chat-session-modeling#single-turn-workflows) [Multi-Turn Workflows](https://useworkflow.dev/docs/ai/chat-session-modeling#multi-turn-workflows) [Choosing a Pattern](https://useworkflow.dev/docs/ai/chat-session-modeling#choosing-a-pattern) [Multiplayer Chat Sessions](https://useworkflow.dev/docs/ai/chat-session-modeling#multiplayer-chat-sessions) [Related Documentation](https://useworkflow.dev/docs/ai/chat-session-modeling#related-documentation)\n\n[GitHubEdit this page on GitHub](https://github.com/vercel/workflow/edit/main/content/docs/ai/chat-session-modeling.mdx) Scroll to topGive feedbackCopy pageAsk AI about this pageOpen in chat\n\n## Chat\n\nWhat is Workflow?How does retrying work?What control flow patterns are there?How do directives work?How do I build an AI agent?\n\nTip: You can open and close chat with `⌘I`\n\n0 / 1000",
  "metadata": {
    "twitter:image:height": "628",
    "language": "en",
    "twitter:title": "Chat Session Modeling",
    "twitter:card": "summary_large_image",
    "twitter:image:type": "image/png",
    "og:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "next-size-adjust": "",
    "ogTitle": "Chat Session Modeling",
    "title": "Chat Session Modeling",
    "twitter:image:width": "1200",
    "og:title": "Chat Session Modeling",
    "og:image:height": "628",
    "ogImage": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "og:image:width": "1200",
    "og:image:type": "image/png",
    "viewport": "width=device-width, initial-scale=1",
    "twitter:image": "https://useworkflow.dev/opengraph-image.png?opengraph-image.f38670ff.png",
    "favicon": "https://useworkflow.dev/favicon.ico?favicon.e7ce0d1c.ico",
    "scrapeId": "019bf2d4-569c-75d7-940e-e77ecca5c1e1",
    "sourceURL": "https://useworkflow.dev/docs/ai/chat-session-modeling",
    "url": "https://useworkflow.dev/docs/ai/chat-session-modeling",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic",
    "cacheState": "hit",
    "cachedAt": "2026-01-24T22:00:38.080Z",
    "creditsUsed": 1
  }
}